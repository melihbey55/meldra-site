from flask import Flask, request, jsonify, send_from_directory
import os, re, random, requests
from collections import deque, defaultdict
from urllib.parse import quote
from datetime import datetime
import time
import hashlib
import logging
import math
from typing import Dict, List, Optional, Tuple, Any

# Logging ayarƒ±
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = Flask(__name__)

# =============================
# √áEVRESEL DEƒûƒ∞≈ûKENLER - G√úVENLƒ∞
# =============================

# Environment variables'dan API key'leri al
WEATHER_API_KEY = os.environ.get('WEATHER_API_KEY', '6a7a443921825622e552d0cde2d2b688')
NEWS_API_KEY = os.environ.get('NEWS_API_KEY', '94ac5f3a6ea34ed0918d28958c7e7aa6')
GOOGLE_SEARCH_KEY = os.environ.get('GOOGLE_SEARCH_KEY', 'AIzaSyCphCUBFyb0bBVMVG5JupVOjKzoQq33G-c')
GOOGLE_CX = os.environ.get('GOOGLE_CX', 'd15c352df36b9419f')
OPENAI_API_KEY = os.environ.get('OPENAI_API_KEY', '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')

# =============================
# GLOBAL DEƒûƒ∞≈ûKENLER
# =============================

conversation_history = defaultdict(lambda: deque(maxlen=20))
user_states = defaultdict(lambda: {'waiting_for_city': False})

# T√ºrk ≈üehirleri
TURKISH_CITIES = [
    "adana", "adiyaman", "afyon", "afyonkarahisar", "agri", "aksaray", "amasya", "ankara", "antalya",
    "ardahan", "artvin", "aydin", "balikesir", "bartin", "batman", "bayburt", "bilecik", "bingol",
    "bitlis", "bolu", "burdur", "bursa", "canakkale", "cankiri", "corum", "denizli", "diyarbakir",
    "duzce", "edirne", "elazig", "erzincan", "erzurum", "eskisehir", "gaziantep", "giresun",
    "gumushane", "hakkari", "hatay", "igdir", "isparta", "istanbul", "izmir", "kahramanmaras",
    "karabuk", "karaman", "kars", "kastamonu", "kayseri", "kilis", "kirikkale", "kirklareli",
    "kirsehir", "kocaeli", "konya", "kutahya", "malatya", "manisa", "mardin", "mersin", "mugla",
    "mus", "nevsehir", "nigde", "ordu", "osmaniye", "rize", "sakarya", "samsun", "sanliurfa",
    "siirt", "sinop", "sivas", "sirnak", "tekirdag", "tokat", "trabzon", "tunceli", "usak",
    "van", "yalova", "yozgat", "zonguldak"
]

# T√ºrk√ße karakter normalizasyonu
TURKISH_CHAR_MAP = {
    'ƒ±': 'i', 'ƒü': 'g', '√º': 'u', '≈ü': 's', '√∂': 'o', '√ß': 'c',
    'ƒ∞': 'i', 'ƒû': 'g', '√ú': 'u', '≈û': 's', '√ñ': 'o', '√á': 'c'
}

# =============================
# S√úPER GELƒ∞≈ûMƒ∞≈û MATEMATƒ∞K MOTORU - TAM Fƒ∞KS
# =============================

class SuperMathEngine:
    def __init__(self):
        self.number_words = {
            "sƒ±fƒ±r": 0, "bir": 1, "iki": 2, "√º√ß": 3, "d√∂rt": 4, "be≈ü": 5,
            "altƒ±": 6, "yedi": 7, "sekiz": 8, "dokuz": 9, "on": 10,
            "yirmi": 20, "otuz": 30, "kƒ±rk": 40, "elli": 50, "altmƒ±≈ü": 60,
            "yetmi≈ü": 70, "seksen": 80, "doksan": 90,
            "y√ºz": 100, "bin": 1000, "milyon": 1000000
        }
        
        self.operation_words = {
            "artƒ±": "+", "eksi": "-", "√ßarpƒ±": "*", "b√∂l√º": "/", "x": "*", "kere": "*",
            "√ºzeri": "**", "karek√∂k": "sqrt", "kare": "**2", "k√ºp": "**3"
        }
        
        self.math_constants = {
            "pi": str(math.pi), "œÄ": str(math.pi),
            "e": str(math.e)
        }
        
        self.trig_functions = {
            "sin": math.sin, "cos": math.cos, "tan": math.tan, "cot": lambda x: 1/math.tan(x),
            "arcsin": math.asin, "arccos": math.acos, "arctan": math.atan
        }

    def parse_turkish_number(self, text: str) -> Optional[float]:
        """T√ºrk√ße yazƒ±lƒ± sayƒ±larƒ± sayƒ±ya √ßevirir"""
        words = text.lower().split()
        total = 0
        current = 0
        
        for word in words:
            if word in self.number_words:
                value = self.number_words[word]
                if value >= 100:
                    if current == 0:
                        current = 1
                    current *= value
                    if value >= 1000:
                        total += current
                        current = 0
                else:
                    current += value
            else:
                # Sayƒ± deƒüilse parsing'i durdur
                break
        
        return total + current if current > 0 else None

    def extract_numbers_from_text(self, text: str) -> List[float]:
        """Metinden sayƒ±larƒ± √ßƒ±karƒ±r"""
        numbers = []
        # Ondalƒ±klƒ± sayƒ±larƒ± ve tam sayƒ±larƒ± bul
        matches = re.findall(r'\d+\.?\d*', text)
        for match in matches:
            try:
                numbers.append(float(match))
            except ValueError:
                continue
        return numbers

    def solve_advanced_math(self, expression: str) -> Optional[str]:
        """Geli≈ümi≈ü matematik problemlerini √ß√∂zer"""
        expr_lower = expression.lower().replace(' ', '')
        numbers = self.extract_numbers_from_text(expression)
        
        # Trigonometri fonksiyonlarƒ±
        trig_patterns = [
            (r'sin\(?(\d+)\)?', lambda x: math.sin(math.radians(float(x)))),
            (r'cos\(?(\d+)\)?', lambda x: math.cos(math.radians(float(x)))),
            (r'tan\(?(\d+)\)?', lambda x: math.tan(math.radians(float(x)))),
            (r'cot\(?(\d+)\)?', lambda x: 1/math.tan(math.radians(float(x)))),
        ]
        
        for pattern, func in trig_patterns:
            match = re.search(pattern, expr_lower)
            if match:
                try:
                    value = float(match.group(1))
                    result = func(value)
                    return f"üßÆ {expression} = {result:.4f}"
                except:
                    pass

        # √ús alma i≈ülemleri
        if '√ºzeri' in expression.lower() or '**' in expression or '^' in expression:
            if numbers and len(numbers) >= 2:
                base = numbers[0]
                exponent = numbers[1]
                result = base ** exponent
                return f"üßÆ {base} √ºzeri {exponent} = {result}"

        # Karek√∂k i≈ülemleri
        if 'karek√∂k' in expression.lower() or 'sqrt' in expression.lower():
            if numbers:
                result = math.sqrt(numbers[0])
                return f"üßÆ ‚àö{numbers[0]} = {result:.4f}"

        # Hipoten√ºs hesaplama
        if 'hipoten√ºs' in expression.lower() or 'hipotenus' in expression.lower():
            if len(numbers) >= 2:
                a, b = numbers[:2]
                hipo = math.sqrt(a**2 + b**2)
                return f"üßÆ {a} ve {b} kenarlƒ± √º√ßgenin hipoten√ºs√º = {hipo:.2f}"

        # Alan hesaplamalarƒ±
        if 'alan' in expression.lower():
            if numbers:
                if 'kare' in expression.lower():
                    a = numbers[0]
                    return f"üßÆ Kenarƒ± {a} olan karenin alanƒ± = {a**2}"
                elif 'dikd√∂rtgen' in expression.lower() and len(numbers) >= 2:
                    a, b = numbers[:2]
                    return f"üßÆ {a} x {b} dikd√∂rtgenin alanƒ± = {a*b}"
                elif 'daire' in expression.lower() or '√ßember' in expression.lower():
                    r = numbers[0]
                    return f"üßÆ Yarƒ±√ßapƒ± {r} olan dairenin alanƒ± = {math.pi * r**2:.2f}"
                elif '√º√ßgen' in expression.lower() and len(numbers) >= 2:
                    a, h = numbers[:2]
                    return f"üßÆ Tabanƒ± {a} ve y√ºksekliƒüi {h} olan √º√ßgenin alanƒ± = {0.5 * a * h}"

        # Hacim hesaplamalarƒ±
        if 'hacim' in expression.lower():
            if numbers:
                if 'k√ºp' in expression.lower():
                    a = numbers[0]
                    return f"üßÆ Kenarƒ± {a} olan k√ºp√ºn hacmi = {a**3}"
                elif 'k√ºre' in expression.lower():
                    r = numbers[0]
                    return f"üßÆ Yarƒ±√ßapƒ± {r} olan k√ºrenin hacmi = {(4/3) * math.pi * r**3:.2f}"
                elif 'silindir' in expression.lower() and len(numbers) >= 2:
                    r, h = numbers[:2]
                    return f"üßÆ Yarƒ±√ßapƒ± {r} ve y√ºksekliƒüi {h} olan silindirin hacmi = {math.pi * r**2 * h:.2f}"

        # Matematik sabitleri
        if 'pi' in expression.lower() or 'œÄ' in expression:
            return f"üßÆ œÄ (pi) sayƒ±sƒ± = {math.pi:.10f}..."

        return None

    def calculate_expression(self, expression: str) -> Optional[float]:
        """Matematik ifadesini g√ºvenli ≈üekilde hesaplar"""
        try:
            # G√ºvenlik kontrol√º - sadece matematiksel karakterlere izin ver
            allowed_chars = set('0123456789+-*/.() ')
            if all(c in allowed_chars for c in expression.replace(' ', '')):
                # Basit i≈ülemler i√ßin eval
                result = eval(expression, {"__builtins__": {}}, {})
                return float(result) if isinstance(result, (int, float)) else None
        except:
            pass
        return None

    def calculate(self, text: str) -> Optional[str]:
        """Ana matematik hesaplama fonksiyonu"""
        # √ñnce geli≈ümi≈ü matematik problemlerini √ß√∂z
        advanced_result = self.solve_advanced_math(text)
        if advanced_result:
            return advanced_result

        # Basit matematik ifadelerini i≈üle
        text_lower = text.lower()
        
        # Matematiksel ifadeleri kontrol et (3+5, 10-2, vb.)
        simple_math_pattern = r'(\d+\.?\d*)\s*([+\-*/])\s*(\d+\.?\d*)'
        match = re.search(simple_math_pattern, text)
        if match:
            try:
                num1 = float(match.group(1))
                operator = match.group(2)
                num2 = float(match.group(3))
                
                if operator == '+':
                    result = num1 + num2
                elif operator == '-':
                    result = num1 - num2
                elif operator == '*':
                    result = num1 * num2
                elif operator == '/':
                    if num2 != 0:
                        result = num1 / num2
                    else:
                        return "‚ùå Sƒ±fƒ±ra b√∂lme hatasƒ±!"
                
                return f"üßÆ {text} = {result}"
            except:
                pass

        # T√ºrk√ße matematik ifadelerini d√∂n√º≈üt√ºr
        math_expr = text_lower
        for turkish, symbol in self.operation_words.items():
            math_expr = math_expr.replace(turkish, symbol)
        
        for constant, value in self.math_constants.items():
            math_expr = math_expr.replace(constant, value)

        # Basit hesaplama deneyelim
        try:
            result = self.calculate_expression(math_expr)
            if result is not None:
                return f"üßÆ {text} = {result}"
        except:
            pass

        # T√ºrk√ße sayƒ±larƒ± i≈üle (√∂rn: "be≈ü artƒ± √º√ß")
        turkish_ops = ['artƒ±', 'eksi', '√ßarpƒ±', 'b√∂l√º']
        if any(op in text_lower for op in turkish_ops):
            parts = re.split(r'(artƒ±|eksi|√ßarpƒ±|b√∂l√º)', text_lower)
            if len(parts) == 3:
                num1_text, op, num2_text = parts
                num1 = self.parse_turkish_number(num1_text.strip())
                num2 = self.parse_turkish_number(num2_text.strip())
                
                if num1 is not None and num2 is not None:
                    if 'artƒ±' in op:
                        return f"üßÆ {text} = {num1 + num2}"
                    elif 'eksi' in op:
                        return f"üßÆ {text} = {num1 - num2}"
                    elif '√ßarpƒ±' in op:
                        return f"üßÆ {text} = {num1 * num2}"
                    elif 'b√∂l√º' in op:
                        if num2 != 0:
                            return f"üßÆ {text} = {num1 / num2}"
                        else:
                            return "‚ùå Sƒ±fƒ±ra b√∂lme hatasƒ±!"

        return None

math_engine = SuperMathEngine()

# =============================
# GELƒ∞≈ûMƒ∞≈û NLP MOTORU - Kƒ∞≈ûƒ∞ SORGULARI TAM Fƒ∞KS
# =============================

class AdvancedNLU:
    def __init__(self):
        self.intent_patterns = {
            'greeting': {
                'patterns': [
                    r'^merhaba$', r'^selam$', r'^hey$', r'^hi$', r'^hello$',
                    r'^g√ºnaydƒ±n$', r'^iyi\s*g√ºnler$', r'^naber$', r'^ne\s*haber$',
                    r'^merhabalar$', r'^selamlar$', r'^heyyo$', r'^hola$'
                ],
                'priority': 25,
                'keywords': ['merhaba', 'selam', 'hey', 'hi', 'hello', 'g√ºnaydƒ±n', 'iyi g√ºnler', 'naber']
            },
            'person_info': {
                'patterns': [
                    r'\bkimdir\b', r'\bkim\s*dƒ±r\b', r'\bkim\s*dir\b', r'\bkim\s*olarak\s*bilinir',
                    r'\bkim\s*denir', r'\bhayatƒ±\s*nedir', r'\bbiografi', r'\bka√ß\s*ya≈üƒ±nda',
                    r'\bnereli', r'\bne\s*i≈ü\s*yapar', r'\bmesleƒüi\s*ne',
                    r'\bdoƒüum\s*tarihi', r'\bdoƒüum\s*yeri', r'\beƒüitim\s*hayatƒ±',
                    r'\bkariyeri', r'\bba≈üarƒ±larƒ±', r'\beserleri', r'\bkim\b'
                ],
                'priority': 20,
                'keywords': ['kimdir', 'kim', 'biyografi', 'ya≈ü', 'doƒüum', 'eƒüitim', 'kariyer', 'hayatƒ±']
            },
            'math': {
                'patterns': [
                    r'\bhesapla', r'\bka√ß\s*eder', r'\btopla', r'\b√ßƒ±kar', r'\b√ßarp', r'\bb√∂l',
                    r'\bartƒ±', r'\beksi', r'\b√ßarpi', r'\bb√∂l√º', r'\bmatematik',
                    r'\bsin', r'\bcos', r'\btan', r'\bcot', r'\bhipoten√ºs', r'\balan',
                    r'\bhacim', r'\bkarek√∂k', r'\bpi\b', r'\bœÄ\b', r'\b√ºzeri',
                    r'\bk√ºp√ºn\s*hacmi', r'\bkarenin\s*alanƒ±', r'\bdairenin\s*alanƒ±',
                    r'\b√º√ßgenin\s*alanƒ±', r'\bk√ºrenin\s*hacmi',
                    r'\d+\s*[\+\-\*\/\^]\s*\d+',
                ],
                'priority': 15,
                'keywords': ['hesapla', 'topla', '√ßƒ±kar', '√ßarp', 'b√∂l', 'artƒ±', 'eksi', 
                           'sin', 'cos', 'tan', 'cot', 'hipoten√ºs', 'alan', 'hacim',
                           'k√ºp', 'kare', 'daire', '√º√ßgen', 'k√ºre', 'karek√∂k', 'pi',
                           '√ºzeri', '√ºs', 'kere']
            },
            'knowledge': {
                'patterns': [
                    r'\bnedir\b', r'\bne\s*demek', r'\bne\s*anlama\s*gelir', r'\banlamƒ±\s*ne',
                    r'\ba√ßƒ±kla\b', r'\bbilgi\s*ver', r'\bne\s*demektir',
                    r'\bhakkƒ±nda\b', r'\btanƒ±m\b', r'\banlam\b', r'\bne\s*denir'
                ],
                'priority': 10,
                'keywords': ['nedir', 'a√ßƒ±kla', 'bilgi', 'anlamƒ±', 'ne demek', 'hakkƒ±nda']
            },
            'weather': {
                'patterns': [
                    r'\bhava\s*durum', r'\bhava\s*ka√ß', r'\bka√ß\s*derece', r'\bsƒ±caklƒ±k\s*ka√ß',
                    r'\bhavasƒ±\s*nasƒ±l', r'\bnem\s*oranƒ±', r'\br√ºzgar\s*≈üiddeti',
                    r'\bhava\s*durumu\s*s√∂yle', r'\bderece\s*ka√ß', r'\bsƒ±caklƒ±k\s*ne'
                ],
                'priority': 8,
                'keywords': ['hava', 'derece', 'sƒ±caklƒ±k', 'nem', 'r√ºzgar']
            },
            'cooking': {
                'patterns': [
                    r'\btarif', r'\bnasƒ±l\s*yapƒ±lƒ±r', r'\byapƒ±mƒ±', r'\bmalzeme',
                    r'\bpi≈üirme', r'\byemek\s*tarifi'
                ],
                'priority': 7,
                'keywords': ['tarif', 'yemek', 'nasƒ±l yapƒ±lƒ±r', 'malzeme']
            },
            'time': {
                'patterns': [
                    r'\bsaat\s*ka√ß', r'\bka√ß\s*saat', r'\bzaman\s*ne', r'\btarih\s*ne',
                    r'\bgun\s*ne'
                ],
                'priority': 6,
                'keywords': ['saat', 'zaman', 'tarih']
            },
            'news': {
                'patterns': [
                    r'\bhaber', r'\bg√ºndem', r'\bson\s*dakika', r'\bgazete', r'\bman≈üet'
                ],
                'priority': 5,
                'keywords': ['haber', 'g√ºndem', 'son dakika']
            },
            'thanks': {
                'patterns': [
                    r'\bte≈üekk√ºr', r'\bsaƒü\s*ol', r'\bthanks', r'\bethank\s*you',
                    r'\beyvallah', r'\bmersi', r'\btebrik', r'\bharika'
                ],
                'priority': 10,
                'keywords': ['te≈üekk√ºr', 'saƒü ol', 'thanks', 'thank you', 'eyvallah']
            }
        }

    def normalize_text(self, text: str) -> str:
        """T√ºrk√ße karakterleri normalize eder"""
        text = text.lower().strip()
        for old, new in TURKISH_CHAR_MAP.items():
            text = text.replace(old, new)
        return text

    def extract_intent(self, text: str) -> Tuple[str, float, Dict]:
        """Metinden intent √ßƒ±karƒ±r"""
        normalized = self.normalize_text(text)
        scores = {}
        intent_details = {}
        
        # √ñNCE SELAMLAMA KONTROL√ú
        if self.is_definite_greeting(normalized):
            scores['greeting'] = 30
        
        # SONRA Kƒ∞≈ûƒ∞ SORGUSU KONTROL√ú
        if self.is_likely_person_query(normalized):
            scores['person_info'] = 25
        
        # SONRA matematik kontrol√º
        if self.is_likely_math(normalized):
            scores['math'] = 20
        
        for intent, data in self.intent_patterns.items():
            if intent in scores:
                continue
                
            score = 0
            pattern_matches = []
            keyword_matches = []
            
            for pattern in data['patterns']:
                if re.search(pattern, normalized):
                    score += 5
                    pattern_matches.append(pattern)
            
            for keyword in data.get('keywords', []):
                if re.search(r'\b' + re.escape(keyword) + r'\b', normalized):
                    score += 3
                    keyword_matches.append(keyword)
            
            score += data['priority']
            scores[intent] = score
            intent_details[intent] = {
                'score': score,
                'pattern_matches': pattern_matches,
                'keyword_matches': keyword_matches
            }
        
        if not scores:
            return 'unknown', 0.0, {}
        
        best_intent = max(scores.items(), key=lambda x: x[1])
        max_score = max(scores.values())
        
        if max_score < 10:
            confidence = 0.0
        else:
            confidence = min(best_intent[1] / (max_score + 0.1), 1.0)
        
        return best_intent[0], confidence, intent_details.get(best_intent[0], {})

    def is_definite_greeting(self, text: str) -> bool:
        """Kesin selamlama ifadelerini kontrol eder"""
        definite_greetings = {
            'merhaba', 'selam', 'hey', 'hi', 'hello', 'hola',
            'g√ºnaydƒ±n', 'iyi g√ºnler', 'naber', 'ne haber',
            'merhabalar', 'selamlar', 'heyyo'
        }
        return text in definite_greetings

    def is_likely_person_query(self, text: str) -> bool:
        """Metnin ki≈üi sorgusu olup olmadƒ±ƒüƒ±nƒ± kontrol eder"""
        # √ñnemli ki≈üi isimleri
        important_people = [
            'recep tayyip erdogan', 'erdogan', 'r t erdogan', 'r.t. erdogan',
            'mustafa kemal ataturk', 'ataturk', 'm k ataturk', 'm.k. ataturk',
            'abdullah gul', 'gul', 'ahmet davutoglu', 'davutoglu',
            'binali yildirim', 'yildirim', 'ismet inonu', 'inonu',
            'kenan evren', 'evren', 'suleyman demirel', 'demirel',
            'turgut ozal', 'ozal', 'celal bayar', 'bayar',
            'kemal kilicdaroglu', 'kilicdaroglu', 'devlet bahceli', 'bahceli',
            'canan', 'ibrahim', 'fatih', 'mehmet', 'ali', 'ay≈üe', 'fatma'
        ]
        
        # Ki≈üi ismi i√ßeriyor mu?
        for person in important_people:
            if person in text:
                return True
        
        # "kim" sorusu var mƒ±?
        if re.search(r'\bkim\b', text) and len(text.split()) <= 5:
            return True
            
        return False

    def is_likely_math(self, text: str) -> bool:
        """Metnin matematik sorgusu olup olmadƒ±ƒüƒ±nƒ± kontrol eder"""
        math_operators = ['+', '-', '*', '/', 'x', '^', 'artƒ±', 'eksi', '√ßarpƒ±', 'b√∂l√º', '√ºzeri']
        if any(op in text for op in math_operators):
            return True
        
        math_funcs = ['sin', 'cos', 'tan', 'cot', 'log', 'ln', 'sqrt', 'karek√∂k']
        if any(func in text for func in math_funcs):
            return True
        
        math_terms = ['hipoten√ºs', 'alan', 'hacim', 'pi', 'œÄ', 'hesapla', 'ka√ß eder', 
                     'k√ºp', 'kare', 'daire', '√º√ßgen', 'k√ºre', '√ºs']
        if any(term in text for term in math_terms):
            return True
        
        if re.search(r'\d+\.?\d*\s*[\+\-\*\/\^x]\s*\d+\.?\d*', text):
            return True
        
        if re.search(r'(k√ºp|kare|daire|√º√ßgen|k√ºre).*\d+', text):
            return True
            
        return False

    def extract_entities(self, text: str) -> Dict[str, Any]:
        """Metinden entity √ßƒ±karƒ±r - GELƒ∞≈ûTƒ∞Rƒ∞LMƒ∞≈û"""
        normalized = self.normalize_text(text)
        entities = {}
        
        # ≈ûehir entity'si
        for city in TURKISH_CITIES:
            city_normalized = self.normalize_text(city)
            if re.search(r'\b' + re.escape(city_normalized) + r'\b', normalized):
                entities['city'] = city
                break
        
        # Ki≈üi ismi entity'si - GELƒ∞≈ûTƒ∞Rƒ∞LMƒ∞≈û
        person_name = self.extract_person_name_from_text(normalized)
        if person_name:
            entities['person'] = person_name
        
        return entities

    def extract_person_name_from_text(self, text: str) -> str:
        """Metinden ki≈üi ismini √ßƒ±karƒ±r - GELƒ∞≈ûTƒ∞Rƒ∞LMƒ∞≈û"""
        # √ñnce bilinen ki≈üi isimlerini kontrol et
        known_people = {
            'recep tayyip erdogan': 'Recep Tayyip Erdoƒüan',
            'erdogan': 'Recep Tayyip Erdoƒüan',
            'r t erdogan': 'Recep Tayyip Erdoƒüan',
            'r.t. erdogan': 'Recep Tayyip Erdoƒüan',
            'mustafa kemal ataturk': 'Mustafa Kemal Atat√ºrk',
            'ataturk': 'Mustafa Kemal Atat√ºrk',
            'm k ataturk': 'Mustafa Kemal Atat√ºrk',
            'm.k. ataturk': 'Mustafa Kemal Atat√ºrk',
            'abdullah gul': 'Abdullah G√ºl',
            'gul': 'Abdullah G√ºl',
            'ahmet davutoglu': 'Ahmet Davutoƒülu',
            'davutoglu': 'Ahmet Davutoƒülu',
            'binali yildirim': 'Binali Yƒ±ldƒ±rƒ±m',
            'yildirim': 'Binali Yƒ±ldƒ±rƒ±m',
            'ismet inonu': 'ƒ∞smet ƒ∞n√∂n√º',
            'inonu': 'ƒ∞smet ƒ∞n√∂n√º',
            'kenan evren': 'Kenan Evren',
            'evren': 'Kenan Evren',
            'suleyman demirel': 'S√ºleyman Demirel',
            'demirel': 'S√ºleyman Demirel',
            'turgut ozal': 'Turgut √ñzal',
            'ozal': 'Turgut √ñzal',
            'celal bayar': 'Celal Bayar',
            'bayar': 'Celal Bayar',
            'kemal kilicdaroglu': 'Kemal Kƒ±lƒ±√ßdaroƒülu',
            'kilicdaroglu': 'Kemal Kƒ±lƒ±√ßdaroƒülu',
            'devlet bahceli': 'Devlet Bah√ßeli',
            'bahceli': 'Devlet Bah√ßeli'
        }
        
        for key, name in known_people.items():
            if key in text:
                return name
        
        # Bilinen ki≈üi yoksa, "kim" kelimesinden √∂nceki kƒ±smƒ± al
        if 'kim' in text:
            parts = text.split('kim')
            if parts[0].strip():
                return parts[0].strip().title()
        
        # "kimdir" varsa ondan √∂nceki kƒ±smƒ± al
        if 'kimdir' in text:
            parts = text.split('kimdir')
            if parts[0].strip():
                return parts[0].strip().title()
        
        return ""

nlu_engine = AdvancedNLU()

# =============================
# API ENTEGRASYON Sƒ∞STEMƒ∞ - OPENAI TAM Fƒ∞KS
# =============================

class IntelligentAPI:
    def __init__(self):
        self.cache = {}
        self.cache_timeout = 300
        
    def get_cache_key(self, source: str, query: str) -> str:
        return f"{source}_{hashlib.md5(query.encode()).hexdigest()}"
    
    def cached_request(self, key: str, func, *args, **kwargs):
        now = time.time()
        if key in self.cache and now - self.cache[key]['timestamp'] < self.cache_timeout:
            return self.cache[key]['data']
        
        result = func(*args, **kwargs)
        if result:
            self.cache[key] = {'data': result, 'timestamp': now}
        return result
    
    def google_search(self, query: str) -> Optional[str]:
        """Google Custom Search API"""
        try:
            cache_key = self.get_cache_key('google', query)
            
            def search():
                if nlu_engine.is_likely_math(query):
                    return None
                    
                url = f"https://www.googleapis.com/customsearch/v1?key={GOOGLE_SEARCH_KEY}&cx={GOOGLE_CX}&q={quote(query)}"
                response = requests.get(url, timeout=10)
                
                if response.status_code == 200:
                    results = response.json()
                    if 'items' in results and results['items']:
                        first_result = results['items'][0]
                        title = first_result.get('title', '')
                        snippet = first_result.get('snippet', '')
                        return f"{title}\n{snippet}"
                return None
            
            return self.cached_request(cache_key, search)
            
        except Exception as e:
            logger.error(f"Google search error: {e}")
            return None
    
    def openai_completion(self, prompt: str, max_tokens: int = 500) -> Optional[str]:
        """OpenAI GPT-3.5 API - GELƒ∞≈ûTƒ∞Rƒ∞LMƒ∞≈û"""
        try:
            cache_key = self.get_cache_key('openai', prompt)
            
            def complete():
                headers = {
                    'Authorization': f'Bearer {OPENAI_API_KEY}',
                    'Content-Type': 'application/json'
                }
                
                data = {
                    'model': 'gpt-3.5-turbo',
                    'messages': [{'role': 'user', 'content': prompt}],
                    'max_tokens': max_tokens,
                    'temperature': 0.7
                }
                
                response = requests.post(
                    'https://api.openai.com/v1/chat/completions',
                    headers=headers,
                    json=data,
                    timeout=30
                )
                
                if response.status_code == 200:
                    result = response.json()
                    return result['choices'][0]['message']['content'].strip()
                else:
                    logger.error(f"OpenAI API error: {response.status_code} - {response.text}")
                    return None
            
            return self.cached_request(cache_key, complete)
            
        except Exception as e:
            logger.error(f"OpenAI error: {e}")
            return None
    
    def get_weather(self, city: str) -> Optional[str]:
        """OpenWeatherMap API"""
        try:
            cache_key = self.get_cache_key('weather', city)
            
            def fetch_weather():
                url = f"http://api.openweathermap.org/data/2.5/weather?q={quote(city)},TR&appid={WEATHER_API_KEY}&units=metric&lang=tr"
                response = requests.get(url, timeout=8)
                
                if response.status_code == 200:
                    data = response.json()
                    temp = data['main']['temp']
                    feels_like = data['main']['feels_like']
                    humidity = data['main']['humidity']
                    desc = data['weather'][0]['description'].capitalize()
                    wind_speed = data.get('wind', {}).get('speed', 'N/A')
                    
                    return (f"üå§Ô∏è {city.title()} Hava Durumu:\n"
                           f"‚Ä¢ Sƒ±caklƒ±k: {temp:.1f}¬∞C (Hissedilen: {feels_like:.1f}¬∞C)\n"
                           f"‚Ä¢ Durum: {desc}\n"
                           f"‚Ä¢ Nem: %{humidity}\n"
                           f"‚Ä¢ R√ºzgar: {wind_speed} m/s\n"
                           f"‚Ä¢ G√ºncelleme: {datetime.now().strftime('%H:%M')}")
                else:
                    return f"‚ùå {city.title()} i√ßin hava durumu bulunamadƒ±."
            
            return self.cached_request(cache_key, fetch_weather)
            
        except Exception as e:
            logger.error(f"Weather API error: {e}")
            return "üå´Ô∏è Hava durumu servisi ge√ßici olarak kullanƒ±lamƒ±yor."

api_client = IntelligentAPI()

# =============================
# KONU≈ûMA Y√ñNETƒ∞Cƒ∞Sƒ∞
# =============================

class ConversationManager:
    def __init__(self):
        self.context_size = 5
    
    def add_message(self, user_id: str, role: str, content: str):
        """Konu≈üma ge√ßmi≈üine mesaj ekler"""
        conversation_history[user_id].append({
            'role': role,
            'content': content,
            'timestamp': datetime.now()
        })

conv_manager = ConversationManager()

# =============================
# ANA CEVAP √úRETME MOTORU - Kƒ∞≈ûƒ∞ SORGULARI TAM Fƒ∞KS
# =============================

class ResponseEngine:
    def __init__(self):
        self.greeting_responses = [
            "Merhaba! Ben Meldra, size nasƒ±l yardƒ±mcƒ± olabilirim? üåü",
            "Selam! Harika g√∂r√ºn√ºyorsunuz! Size nasƒ±l yardƒ±m edebilirim? üòä",
            "Hey! Meldra burada. Ne yapmak istersiniz? üöÄ",
            "Merhaba! Bug√ºn size nasƒ±l yardƒ±mcƒ± olabilirim? üí´",
            "Selam! Sohbet etmek i√ßin hazƒ±rƒ±m! üéâ"
        ]
        
        self.thanks_responses = [
            "Rica ederim! Size yardƒ±mcƒ± olabildiƒüim i√ßin mutluyum! üòä",
            "Ne demek! Her zaman buradayƒ±m! üåü",
            "Ben te≈üekk√ºr ederim! Ba≈üka bir ≈üeye ihtiyacƒ±nƒ±z var mƒ±? üéâ",
            "Asƒ±l ben te≈üekk√ºr ederim! Sorularƒ±nƒ±z beni geli≈ütiriyor! üí™"
        ]

    def generate_response(self, message: str, user_id: str = "default") -> str:
        """Ana cevap √ºretme fonksiyonu"""
        start_time = time.time()
        
        conv_manager.add_message(user_id, 'user', message)
        
        # √ñNCE SELAMLAMA KONTROL√ú
        normalized_message = nlu_engine.normalize_text(message)
        if nlu_engine.is_definite_greeting(normalized_message):
            greeting_response = random.choice(self.greeting_responses)
            self.finalize_response(user_id, greeting_response, start_time)
            return greeting_response
        
        # SONRA Kƒ∞≈ûƒ∞ SORGUSU KONTROL√ú
        if nlu_engine.is_likely_person_query(normalized_message):
            person_response = self.handle_person_info_intent(message)
            if person_response:
                self.finalize_response(user_id, person_response, start_time)
                return person_response
        
        # SONRA matematik kontrol√º
        math_result = math_engine.calculate(message)
        if math_result:
            self.finalize_response(user_id, math_result, start_time)
            return math_result
        
        # SONRA NLU analizi
        intent, confidence, intent_details = nlu_engine.extract_intent(message)
        entities = nlu_engine.extract_entities(message)
        
        logger.info(f"NLU Analysis - Intent: {intent}, Confidence: {confidence:.2f}, Entities: {entities}")
        
        state = user_states[user_id]
        
        if state.get('waiting_for_city'):
            return self.handle_city_response(message, user_id, intent, entities)
        
        if confidence > 0.6:
            response = self.handle_intent(intent, confidence, entities, message, user_id, intent_details)
            if response:
                self.finalize_response(user_id, response, start_time)
                return response
        
        return self.handle_unknown_intent(message, user_id)

    def handle_city_response(self, message: str, user_id: str, intent: str, entities: Dict) -> str:
        """≈ûehir beklerken gelen mesajƒ± i≈üler"""
        state = user_states[user_id]
        
        for city in TURKISH_CITIES:
            if city in nlu_engine.normalize_text(message):
                state['waiting_for_city'] = False
                weather = api_client.get_weather(city)
                return weather
        
        if intent in ['thanks', 'greeting']:
            state['waiting_for_city'] = False
            if intent == 'thanks':
                return random.choice(self.thanks_responses)
            else:
                return random.choice(self.greeting_responses)
        
        return "üå§Ô∏è Hangi ≈üehir i√ßin hava durumu bilgisi istiyorsunuz? L√ºtfen sadece ≈üehir ismi yazƒ±n."

    def handle_intent(self, intent: str, confidence: float, entities: Dict, message: str, user_id: str, intent_details: Dict) -> Optional[str]:
        """Intent'i i≈üler"""
        state = user_states[user_id]
        
        if intent == 'greeting':
            return random.choice(self.greeting_responses)
        
        elif intent == 'thanks':
            return random.choice(self.thanks_responses)
        
        elif intent == 'weather':
            return self.handle_weather_intent(entities, user_id)
        
        elif intent == 'person_info':
            return self.handle_person_info_intent(message)
        
        elif intent == 'knowledge':
            return self.handle_knowledge_intent(message)
        
        elif intent == 'math':
            math_result = math_engine.calculate(message)
            if math_result:
                return math_result
            return "‚ùå Matematik i≈ülemini anlayamadƒ±m. L√ºtfen ≈üu ≈üekillerde sorun:\n‚Ä¢ '5 + 3' veya '5 artƒ± 3'\n‚Ä¢ 'sin 30' veya 'cos 45'\n‚Ä¢ '3 ve 4 hipoten√ºs'\n‚Ä¢ 'kenarƒ± 5 olan karenin alanƒ±'"
        
        elif intent == 'time':
            now = datetime.now()
            days = ["Pazartesi", "Salƒ±", "√áar≈üamba", "Per≈üembe", "Cuma", "Cumartesi", "Pazar"]
            return f"üïí {now.strftime('%H:%M:%S')} - {now.strftime('%d/%m/%Y')} {days[now.weekday()]}"
        
        return None

    def handle_weather_intent(self, entities: Dict, user_id: str) -> Optional[str]:
        """Hava durumu sorgularƒ±nƒ± i≈üler"""
        state = user_states[user_id]
        city = entities.get('city')
        
        if city:
            return api_client.get_weather(city)
        else:
            state['waiting_for_city'] = True
            return "üå§Ô∏è Hangi ≈üehir i√ßin hava durumu bilgisi istiyorsunuz?"

    def handle_person_info_intent(self, message: str) -> str:
        """Ki≈üi bilgisi sorgularƒ±nƒ± i≈üler - TAM Fƒ∞KS"""
        entities = nlu_engine.extract_entities(message)
        person_name = entities.get('person', '')
        
        if not person_name:
            person_name = nlu_engine.extract_person_name_from_text(nlu_engine.normalize_text(message))
        
        if not person_name:
            # Eƒüer hala person_name yoksa, mesajdan ki≈üi ismini √ßƒ±karmaya √ßalƒ±≈ü
            cleaned_message = re.sub(r'\b(kimdir|kim|hakkƒ±nda|biyografi|hayatƒ±|ka√ß|nereli|ne i≈ü yapar)\b', '', message, flags=re.IGNORECASE).strip()
            if cleaned_message and len(cleaned_message) > 3:
                person_name = cleaned_message.title()
            else:
                person_name = "Bu ki≈üi"

        if person_name and person_name != "Bu ki≈üi":
            # OpenAI'a √∂zel olarak ki≈üi bilgisi i√ßin prompt g√∂nder
            prompt = (
                f"'{person_name}' hakkƒ±nda detaylƒ± ve doƒüru bilgi ver. "
                f"L√ºtfen ≈üu bilgileri i√ßeren kapsamlƒ± bir biyografi sun:\n"
                f"- Doƒüum tarihi ve yeri\n"
                f"- Eƒüitim hayatƒ±\n" 
                f"- Kariyeri ve √∂nemli pozisyonlarƒ±\n"
                f"- Ba≈üarƒ±larƒ± ve eserleri\n"
                f"- √ñnemli olaylar ve tarihler\n\n"
                f"Bilgileri maddeler halinde ve net bir ≈üekilde ver. "
                f"Kendi c√ºmlelerinle √∂zetle ve doƒüru bilgiler ver."
            )
            
            logger.info(f"OpenAI prompt for person: {person_name}")
            ai_response = api_client.openai_completion(prompt, max_tokens=600)
            
            if ai_response and len(ai_response) > 50:
                return f"üë§ {person_name} Hakkƒ±nda:\n\n{ai_response}"
            else:
                # OpenAI cevap vermezse Google search yap
                search_query = f"{person_name} kimdir biyografi"
                search_result = api_client.google_search(search_query)
                if search_result:
                    return f"üîç {search_result}"
                else:
                    return f"ü§î {person_name} hakkƒ±nda detaylƒ± bilgi bulunamadƒ±. L√ºtfen daha spesifik bir soru sorun."
        
        return self.handle_knowledge_intent(message)

    def handle_knowledge_intent(self, message: str) -> str:
        """Bilgi sorgularƒ±nƒ± i≈üler"""
        enhanced_prompt = (
            f"Kullanƒ±cƒ± ≈üunu sordu: '{message}'. "
            f"L√ºtfen detaylƒ±, kapsamlƒ± ve doƒüru bir cevap ver. "
            f"Eƒüer bir ki≈üi, yer, olay veya kavram hakkƒ±ndaysa:\n"
            f"- Temel bilgileri ver\n"
            f"- √ñnemli detaylarƒ± ekle\n" 
            f"- Tarihsel baƒülamƒ± a√ßƒ±kla\n"
            f"- G√ºncel bilgileri dahil et\n"
            f"Kendi c√ºmlelerinle √∂zetle ve bilgiyi d√ºzenli sun."
        )
        
        ai_response = api_client.openai_completion(enhanced_prompt, max_tokens=500)
        
        if ai_response and len(ai_response) > 30:
            return f"ü§ñ {ai_response}"
        
        search_result = api_client.google_search(message)
        if search_result:
            return f"üîç {search_result}"
        
        return "ü§î Bu konuda yeterli bilgim bulunmuyor. L√ºtfen sorunuzu farklƒ± ≈üekilde ifade edin veya daha spesifik bir soru sorun."

    def handle_unknown_intent(self, message: str, user_id: str) -> str:
        """Bilinmeyen intent'leri i≈üler"""
        normalized_message = nlu_engine.normalize_text(message)
        if nlu_engine.is_definite_greeting(normalized_message):
            return random.choice(self.greeting_responses)
        
        if nlu_engine.is_likely_person_query(normalized_message):
            return self.handle_person_info_intent(message)
        
        math_result = math_engine.calculate(message)
        if math_result:
            return math_result
        
        ai_response = api_client.openai_completion(
            f"Kullanƒ±cƒ± ≈üunu sordu: '{message}'. "
            "Kƒ±sa, net ve bilgilendirici bir cevap ver."
        )
        
        if ai_response:
            return ai_response
        
        return "ü§î Anlayamadƒ±m, l√ºtfen daha a√ßƒ±klayƒ±cƒ± ≈üekilde sorabilir misiniz?"

    def finalize_response(self, user_id: str, response: str, start_time: float):
        """Cevabƒ± sonlandƒ±rƒ±r ve loglar"""
        conv_manager.add_message(user_id, 'assistant', response)
        response_time = (time.time() - start_time) * 1000
        logger.info(f"Response generated in {response_time:.2f}ms")

response_engine = ResponseEngine()

# =============================
# FLASK ROUTE'LARI
# =============================

@app.route("/")
def index():
    """Ana sayfa - Geli≈ümi≈ü sohbet aray√ºz√º"""
    return """
    <!DOCTYPE html>
    <html lang="tr">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>MELDRA AI - Ultra Geli≈ümi≈ü Yapay Zeka</title>
        <style>
            * { margin: 0; padding: 0; box-sizing: border-box; }
            body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: #333; min-height: 100vh; padding: 20px; }
            .container { max-width: 1000px; margin: 0 auto; background: white; border-radius: 20px; box-shadow: 0 20px 40px rgba(0,0,0,0.1); overflow: hidden; }
            .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; text-align: center; }
            .header h1 { font-size: 2.5em; margin-bottom: 10px; }
            .header p { opacity: 0.9; font-size: 1.1em; }
            .chat-container { display: flex; height: 600px; }
            .sidebar { width: 300px; background: #f8f9fa; padding: 20px; border-right: 1px solid #e9ecef; overflow-y: auto; }
            .features-grid { display: flex; flex-direction: column; gap: 15px; }
            .feature-card { background: white; padding: 15px; border-radius: 10px; border-left: 4px solid #667eea; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
            .feature-card h4 { color: #667eea; margin-bottom: 5px; display: flex; align-items: center; gap: 8px; }
            .chat-area { flex: 1; display: flex; flex-direction: column; }
            .messages { flex: 1; padding: 20px; overflow-y: auto; background: #fafafa; }
            .message { margin-bottom: 15px; padding: 12px 16px; border-radius: 15px; max-width: 80%; word-wrap: break-word; }
            .user-message { background: #667eea; color: white; margin-left: auto; border-bottom-right-radius: 5px; }
            .bot-message { background: white; border: 1px solid #e9ecef; margin-right: auto; border-bottom-left-radius: 5px; }
            .input-area { padding: 20px; border-top: 1px solid #e9ecef; background: white; }
            .input-group { display: flex; gap: 10px; }
            #messageInput { flex: 1; padding: 12px 16px; border: 1px solid #ddd; border-radius: 25px; outline: none; font-size: 16px; }
            #messageInput:focus { border-color: #667eea; }
            #sendButton { padding: 12px 24px; background: #667eea; color: white; border: none; border-radius: 25px; cursor: pointer; font-size: 16px; transition: background 0.3s; }
            #sendButton:hover { background: #5a6fd8; }
            .typing-indicator { display: none; padding: 10px 16px; color: #666; font-style: italic; }
            .status-dot { display: inline-block; width: 8px; height: 8px; border-radius: 50%; background: #4CAF50; margin-right: 5px; }
            .api-status { background: rgba(102, 126, 234, 0.1); padding: 10px; border-radius: 10px; margin-top: 15px; font-size: 0.9em; }
            .examples { background: rgba(40, 167, 69, 0.1); padding: 10px; border-radius: 10px; margin-top: 15px; font-size: 0.8em; }
            .examples h5 { color: #28a745; margin-bottom: 5px; }
        </style>
    </head>
    <body>
        <div class="container">
            <div class="header">
                <h1>üöÄ MELDRA AI v6.5</h1>
                <p>Kƒ∞≈ûƒ∞ SORGULARI TAM Fƒ∞KS + OPENAI ENTEGRASYONU</p>
            </div>
            
            <div class="chat-container">
                <div class="sidebar">
                    <div class="features-grid">
                        <div class="feature-card">
                            <h4>üë§ Kƒ∞≈ûƒ∞ Bƒ∞LGƒ∞LERƒ∞</h4>
                            <p>Artƒ±k ki≈üi sorgularƒ± √ßalƒ±≈üƒ±yor!</p>
                        </div>
                        <div class="feature-card">
                            <h4>üßÆ S√ºper Matematik</h4>
                            <p>Google'a sormuyor!</p>
                        </div>
                        <div class="feature-card">
                            <h4>üëã Selamlama</h4>
                            <p>Merhaba, selam √ßalƒ±≈üƒ±yor</p>
                        </div>
                        <div class="feature-card">
                            <h4>üå§Ô∏è Hava Durumu</h4>
                            <p>Ger√ßek zamanlƒ± hava bilgileri</p>
                        </div>
                    </div>
                    
                    <div class="api-status">
                        <p><span class="status-dot"></span> Ki≈üi Sorgularƒ±: AKTƒ∞F</p>
                        <p><span class="status-dot"></span> OpenAI: √áALI≈ûIYOR</p>
                        <p><span class="status-dot"></span> Matematik: SORUNSUZ</p>
                    </div>
                    
                    <div class="examples">
                        <h5>üéØ TEST SORGULARI:</h5>
                        <p>‚Ä¢ merhaba</p>
                        <p>‚Ä¢ recep tayyip erdoƒüan kimdir</p>
                        <p>‚Ä¢ atat√ºrk kim</p>
                        <p>‚Ä¢ kenarƒ± 4 olan k√ºp√ºn hacmi</p>
                        <p>‚Ä¢ 2 √ºzeri 3</p>
                    </div>
                </div>
                
                <div class="chat-area">
                    <div class="messages" id="messages">
                        <div class="message bot-message">
                            üöÄ <strong>MELDRA AI v6.5</strong> - Kƒ∞≈ûƒ∞ SORGULARI TAM Fƒ∞KS!<br><br>
                            üéØ <strong>YENƒ∞ √ñZELLƒ∞KLER:</strong><br>
                            ‚Ä¢ "recep tayyip erdoƒüan kimdir" = DETAYLI Bƒ∞LGƒ∞<br>
                            ‚Ä¢ "atat√ºrk kim" = DETAYLI Bƒ∞LGƒ∞<br>
                            ‚Ä¢ T√ºm ki≈üi sorgularƒ± √ßalƒ±≈üƒ±yor<br>
                            ‚Ä¢ OpenAI entegrasyonu aktif<br><br>
                            Hemen bir ki≈üi sorusu sorun! üë§
                        </div>
                    </div>
                    
                    <div class="typing-indicator" id="typingIndicator">
                        Meldra yazƒ±yor...
                    </div>
                    
                    <div class="input-area">
                        <div class="input-group">
                            <input type="text" id="messageInput" placeholder="Ki≈üi sorusu sorun..." autocomplete="off">
                            <button id="sendButton">G√∂nder</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <script>
            const messagesContainer = document.getElementById('messages');
            const messageInput = document.getElementById('messageInput');
            const sendButton = document.getElementById('sendButton');
            const typingIndicator = document.getElementById('typingIndicator');
            
            function addMessage(content, isUser = false) {
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${isUser ? 'user-message' : 'bot-message'}`;
                messageDiv.innerHTML = content.replace(/\\n/g, '<br>');
                messagesContainer.appendChild(messageDiv);
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }
            
            function showTyping() {
                typingIndicator.style.display = 'block';
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }
            
            function hideTyping() {
                typingIndicator.style.display = 'none';
            }
            
            async function sendMessage() {
                const message = messageInput.value.trim();
                if (!message) return;
                
                addMessage(message, true);
                messageInput.value = '';
                
                showTyping();
                
                try {
                    const response = await fetch('/chat', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            mesaj: message,
                            user_id: 'web_user'
                        })
                    });
                    
                    const data = await response.json();
                    
                    hideTyping();
                    
                    if (data.status === 'success') {
                        addMessage(data.cevap);
                    } else {
                        addMessage('‚ùå Bir hata olu≈ütu. L√ºtfen tekrar deneyin.');
                    }
                } catch (error) {
                    hideTyping();
                    addMessage('‚ùå Baƒülantƒ± hatasƒ±. L√ºtfen tekrar deneyin.');
                }
            }
            
            messageInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    sendMessage();
                }
            });
            
            sendButton.addEventListener('click', sendMessage);
            
            messageInput.focus();
        </script>
    </body>
    </html>
    """

@app.route("/chat", methods=["POST"])
def chat():
    try:
        data = request.get_json(force=True)
        mesaj = data.get("mesaj", "").strip()
        user_id = data.get("user_id", "default")
        
        if not mesaj:
            return jsonify({
                "cevap": "L√ºtfen bir mesaj girin.",
                "status": "error"
            })
        
        cevap = response_engine.generate_response(mesaj, user_id)
        
        return jsonify({
            "cevap": cevap,
            "status": "success",
            "timestamp": datetime.now().isoformat()
        })
        
    except Exception as e:
        logger.error(f"Chat endpoint error: {e}")
        return jsonify({
            "cevap": "‚ö†Ô∏è Sistem ge√ßici olarak hizmet veremiyor. L√ºtfen daha sonra tekrar deneyin.",
            "status": "error"
        })

@app.route("/status", methods=["GET"])
def status():
    return jsonify({
        "status": "active", 
        "version": "6.5.0",
        "timestamp": datetime.now().isoformat(),
        "features": [
            "Kƒ∞≈ûƒ∞ SORGULARI TAM Fƒ∞KS",
            "OPENAI ENTEGRASYONU AKTƒ∞F", 
            "MATEMATƒ∞K MOTORU SORUNSUZ",
            "SELAMLAMA Sƒ∞STEMƒ∞ √áALI≈ûIYOR"
        ],
        "statistics": {
            "active_users": len(conversation_history),
            "cached_items": len(api_client.cache),
            "uptime": "running"
        }
    })

@app.route("/clear_cache", methods=["POST"])
def clear_cache():
    api_client.cache.clear()
    user_states.clear()
    return jsonify({"status": "Cache and states cleared"})

@app.route("/reset", methods=["POST"])
def reset_state():
    data = request.get_json(force=True)
    user_id = data.get("user_id", "default")
    user_states[user_id] = {'waiting_for_city': False}
    return jsonify({"status": f"State reset for user {user_id}"})

if __name__ == "__main__":
    port = int(os.environ.get("PORT", 5000))
    
    print("üöÄ" * 60)
    print("üöÄ MELDRA AI v6.5 - Kƒ∞≈ûƒ∞ SORGULARI TAM Fƒ∞KS!")
    print("üöÄ Port:", port)
    print("üöÄ √ñZELLƒ∞KLER:")
    print("üöÄ   ‚Ä¢ 'recep tayyip erdoƒüan kimdir' = DETAYLI Bƒ∞LGƒ∞")
    print("üöÄ   ‚Ä¢ 'atat√ºrk kim' = DETAYLI Bƒ∞LGƒ∞") 
    print("üöÄ   ‚Ä¢ T√ºm ki≈üi sorgularƒ± √ßalƒ±≈üƒ±yor")
    print("üöÄ   ‚Ä¢ OpenAI entegrasyonu aktif")
    print("üöÄ" * 60)
    
    app.run(host="0.0.0.0", port=port, debug=False)
